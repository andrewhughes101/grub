#!/bin/bash

# grub_client: grub --help for syntax
VERSION="0.2.0"

syntax()
{
  echo "\
Usage: grub_client [options] <server> [build_command]

Options:
  -v | --verbose              : print verbose output
  -h | --help                 : print this usage information
  -o | --output               : print the stdout and stderr returned from the remote
  --version                   : print version information
  --repo-path <path>          : path to repository (default: current directory)
  --server-root <path>        : remote root directory (default: ~/dev)
  --git-dir <path>            : git directory on server (default: auto-detect by platform)

Arguments:
  server         : ssh host specification (from ~/.ssh/config)
  build_command  : command to run on server (default: ./build)

Examples:
  1. Build current directory repository (uses defaults):
     cd /path/to/myrepo
     grub_client myserver

  2. Build with custom build command:
     grub_client myserver make

  3. Build specific repository:
     grub_client --repo-path \$HOME/projects/myapp myserver

  4. Override server root directory:
     grub_client --server-root /u/user/projects myserver

  5. Override git directory (for non-standard installations):
     grub_client --git-dir /opt/git/bin myserver

  6. From VSCode (uses workspace folder automatically):
     grub_client --repo-path \${workspaceFolder} myserver

Environment Variables:
  TMPDIR : temporary directory for local files (default: /tmp)
           Remote server also honors TMPDIR for its temporary files

Defaults:
  - server_root: ~/dev (expands to remote user's home directory)
  - git_dir: /usr/lpp/IBM/foz/v1r1/bin (z/OS) or /usr/bin (other platforms)
  - build_command: ./build

Notes:
  - Repository name is automatically extracted from the path
  - Platform detection happens on the remote server
  - grub_client uses git and ssh to communicate with the remote server
  - ssh should be configured with public/private key authentication
  - ssh Host specification must include at least HostName and User
  - grub_server script is automatically transferred to the remote server
" >&2
}

reset_origin_url()
{
  active_origin_url=$1

  # switch back to origin url that was active before build
  git config remote.origin.url "${active_origin_url}"
  if [ $? -gt 0 ]; then
    echo "Error: Problems trying to update remote.origin.url to ${active_origin_url}" >&2
    exit 4
  fi
  git config "branch.${active_branch}.remote" "${active_origin_url}"
  if [ $? -gt 0 ]; then
    echo "Error: Problems trying to update branch.${active_branch}.remote to ${active_origin_url}" >&2
    exit 4
  fi
}

vecho()
{
  if [ "${verbose}" = "True" ]; then
    echo "$*"
  fi
}

# Function to push to remote repository
push_to_remote()
{
  local server_repo=$1
  local detached=$2
  local branch_name=$3

  # Push with --force to overwrite remote state
  # The server will only keep what we push due to receive.denyCurrentBranch updateInstead
  if [ $detached -gt 0 ]; then
    echo "On detached HEAD, pushing using temporary branch '$branch_name'"
    git branch $branch_name 2>/dev/null || true  # Branch might already exist
    git push --force --verbose -u "${server_repo}" $branch_name
  else
    git push --force --verbose "${server_repo}"
  fi

  return $?
}

# Cleanup function called on exit via trap
cleanup()
{
  # Don't call exit here - just do cleanup and return
  # The original exit code will be preserved

  # Clean up temporary branch if we made one
  if [ -n "$DETACHED" ] && [ $DETACHED -gt 0 ] && [ -n "$DETACHED_BRANCH_NAME" ]; then
    git branch -D $DETACHED_BRANCH_NAME 2>/dev/null || true
  fi

  # Clean up the remote we added
  if [ -n "$server" ] && [ -n "$repo" ]; then
    git remote remove "${server}_${repo}" 2>/dev/null || true
  fi

  # Clean up local patch file if it exists
  if [ -n "$patch_file" ] && [ -f "$patch_file" ]; then
    rm -f "$patch_file" 2>/dev/null || true
  fi
}

#set -x

# Set up trap to ensure cleanup on exit
trap cleanup EXIT INT TERM

# Parse options
verbose=False
output=False
repo_path=""
server_root='~/dev'  # Default to ~/dev (will expand on remote)
git_dir=""  # Will be auto-detected if not specified

while [[ $# -gt 0 ]]; do
  case "$1" in
    -v|--verbose)
      verbose=True
      shift
      ;;
    -o|--output)
      output=True
      shift
      ;;
    --repo-path)
      if [ -z "$2" ]; then
        echo "Error: --repo-path requires a path argument" >&2
        exit 4
      fi
      repo_path="$2"
      shift 2
      ;;
    --server-root)
      if [ -z "$2" ]; then
        echo "Error: --server-root requires a path argument" >&2
        exit 4
      fi
      server_root="$2"
      shift 2
      ;;
    --git-dir)
      if [ -z "$2" ]; then
        echo "Error: --git-dir requires a path argument" >&2
        exit 4
      fi
      git_dir="$2"
      shift 2
      ;;
    -h|--help)
      syntax
      exit 0
      ;;
    --version)
      echo "grub_client version $VERSION"
      exit 0
      ;;
    -*)
      echo "Error: Unknown option: $1" >&2
      syntax
      exit 4
      ;;
    *)
      # First non-option argument, stop parsing options
      break
      ;;
  esac
done

# Parse positional arguments
server=$1
build_command=${2:-'./build'}

vecho "Remaining arguments after option parsing: $#"
vecho "Server: $server"
vecho "Build command: $build_command"

if [[ $# -lt 1 || $# -gt 2 ]]; then
  syntax
  exit 4
fi

# If git_dir not specified, detect it now (needed for git push configuration)
if [ -z "$git_dir" ]; then
  vecho "Auto-detecting git directory on remote server..."
  # Check if remote is z/OS by looking for common z/OS indicators
  remote_uname=$(ssh "${server}" "uname -s" 2>/dev/null)
  if echo "$remote_uname" | grep -qi "OS/390"; then
    git_dir="/usr/lpp/IBM/foz/v1r1/bin"
    vecho "Detected z/OS platform, using git_dir: $git_dir"
  else
    git_dir="/usr/bin"
    vecho "Detected non-z/OS platform, using git_dir: $git_dir"
  fi
else
  vecho "Using specified git_dir: $git_dir"
fi

# Determine repository path
if [ -z "$repo_path" ]; then
  # Default to current working directory
  repo_path="$PWD"
  vecho "Using current directory as repository path: $repo_path"
fi

# Validate and normalize the repository path
if ! [ -d "$repo_path" ]; then
  echo "Error: Repository path '$repo_path' does not exist" >&2
  exit 8
fi

if ! cd "$repo_path" ; then
  echo "Unable to change into repository directory: $repo_path" >&2
  exit 8
fi

# Get absolute normalized path
repo_path=$(pwd -P)
vecho "Normalized repository path: $repo_path"

# Extract repository name from path
repo=$(basename "$repo_path")
vecho "Repository name: $repo"

vecho "Start:" $(date)
seconds_start=$(date '+%s')

active_origin_url=$(git config --get remote.origin.url)
if [ "${active_origin_url}" = '' ]; then
  echo "Error: Unable to retrieve current remote origin url" >&2
  exit 4
fi

url=$(git config --get "remote.${server}_${repo}.url")
if [ "${url}" = '' ]; then
  git remote add "${server}_${repo}" "${server}:${server_root}/${repo}"
  if [ $? -gt 0 ]; then
    echo "Error: Unable to set url for ${server}_${repo}" >&2
    exit 4
  fi
fi

uploadpack=$(git config --get "remote.${server}_${repo}.uploadpack")
if [ "${uploadpack}" = '' ]; then
  git config --add "remote.${server}_${repo}.uploadpack" "${git_dir}/git-upload-pack"
  if [ $? -gt 0 ]; then
    echo "Error: Unable to add configuration for remote.${server}_${repo}.uploadpack" >&2
    exit 4
  fi
fi
receivepack=$(git config --get "remote.${server}_${repo}.receivepack")
if [ "${receivepack}" = '' ]; then
  git config --add "remote.${server}_${repo}.receivepack" "${git_dir}/git-receive-pack"
  if [ $? -gt 0 ]; then
    echo "Error: Unable to add configuration for remote.${server}_${repo}.receive-pack" >&2
    exit 4
  fi
fi

# Before pushing check if we're in a detached HEAD and push a temporary branch instead

git symbolic-ref -q HEAD >/dev/null 2>&1
DETACHED=$?
DETACHED_BRANCH_NAME="detached-head-branch"

if [ $DETACHED -gt 0 ]; then
  active_branch="$DETACHED_BRANCH_NAME"
else
  active_branch=$(git rev-parse --abbrev-ref HEAD)
  if [ $? -gt 0 ]; then
    echo "Unable to determine current local branch" >&2
    exit 8
  fi
fi

# Check if there are unstaged changes and create a patch file if needed
# Remove trailing slash from TMPDIR if present
client_tmpdir="${TMPDIR:-/tmp}"
client_tmpdir="${client_tmpdir%/}"
patch_file="${client_tmpdir}/grub_${server}_${repo}.patch"
has_unstaged_changes=0

# Check for unstaged changes (both tracked and untracked files)
if ! git diff --exit-code --quiet || ! git diff --cached --exit-code --quiet || [ -n "$(git ls-files --others --exclude-standard)" ]; then
  has_unstaged_changes=1
  vecho "Creating patch file for unstaged changes"

  # Create a comprehensive patch that includes:
  # 1. Unstaged changes to tracked files
  # 2. Staged changes
  # 3. Untracked files
  {
    # First, output diff for tracked files (staged and unstaged)
    git diff HEAD

    # Then, add untracked files as new file patches
    git ls-files --others --exclude-standard | while read -r file; do
      # Count lines in the file
      line_count=$(wc -l < "$file" | tr -d ' ')
      # Handle files with no trailing newline
      if [ -s "$file" ] && [ "$(tail -c 1 "$file" | wc -l)" -eq 0 ]; then
        line_count=$((line_count + 1))
      fi

      echo "diff --git a/$file b/$file"
      echo "new file mode 100644"
      echo "index 0000000000..0000000000"
      echo "--- /dev/null"
      echo "+++ b/$file"
      echo "@@ -0,0 +1,$line_count @@"
      # Add file content with + prefix for each line
      awk '{print "+" $0}' "$file"
    done
  } > "$patch_file"

  if [ ! -s "$patch_file" ]; then
    # Patch file is empty, no changes after all
    has_unstaged_changes=0
    rm -f "$patch_file"
  else
    vecho "Patch file created: $patch_file"
  fi
fi

seconds_patch=$(date '+%s')

#
# msf - If you are not using fast-forwarding, you may have to do a force-lease
# to publish your changes to github.ibm.com
# If you want to avoid this and are ok with it, you can do:
#   git config pull.ff true
# to specify fast-forwarding.
# You can also do it globally if you want, e.g.
#   git config --global pull.ff true
# See: https://thelinuxcode.com/use-pull-rebase-false-pull-ff-true-git/

#
# The --force-with-lease is required because we may have reset the head one or more times
# If you get a message about 'stale info' then this might require 'git remote prune origin'
# (msf - this particular 'git push' needs some more homework)
#
vecho "Synchronize changes from ${repo_path} to ${server}"

# Clean the remote working directory before pushing to avoid rejection
# This is needed because receive.denyCurrentBranch updateInstead requires a clean working tree
# We only clean unstaged changes and untracked files, without touching HEAD
# The subsequent push --force will update HEAD, and updateInstead will update the working tree
ssh "${server}" "cd ${server_root}/${repo} 2>/dev/null && ${git_dir}/git checkout -- . >/dev/null 2>&1 && ${git_dir}/git clean -fd >/dev/null 2>&1" 2>/dev/null || true

# Try to push to remote (suppress errors if repo doesn't exist yet)
push_to_remote "${server}_${repo}" $DETACHED "$DETACHED_BRANCH_NAME" 2>/dev/null

if [ $? -gt 1 ]; then
  echo "Unable to push to remote - try to set up repository ${repo} on ${server_root}"
  ssh "${server}" "mkdir -p ${server_root}/${repo} && cd ${server_root}/${repo} && ${git_dir}/git init && ${git_dir}/git config --local receive.denyCurrentBranch updateInstead"
  if [ $? -gt 0 ]; then
    echo "Error: Failed to push to remote repo: ${server}_${repo} and attempt to create repository on server failed." >&2
    reset_origin_url "${active_origin_url}"
    exit 4
  fi

  # Retry push after setting up repository
  push_to_remote "${server}_${repo}" $DETACHED "$DETACHED_BRANCH_NAME"
  if [ $? -gt 0 ]; then
    echo "Error: Unable to push to ${server}_${repo}." >&2
    reset_origin_url "${active_origin_url}"
    exit 4
  fi
fi

seconds_sync=$(date '+%s')

vecho "Repository synchronized:" $(date)

# Restore origin URL
reset_origin_url "${active_origin_url}"

# Transfer patch file to server if we have unstaged changes
if [ $has_unstaged_changes -eq 1 ]; then
  vecho "Transferring patch file to server"
  # Use /tmp on the server
  server_patch_file="/tmp/grub.${server}_${repo}.patch"

  scp -q "$patch_file" "${server}:${server_patch_file}"
  if [ $? -gt 0 ]; then
    echo "Error: Failed to transfer patch file to server" >&2
    exit 4
  fi
  vecho "Patch file transferred to ${server}:${server_patch_file}"
fi

seconds_transfer=$(date '+%s')

vecho "Patch transfer complete:" $(date)

client_dir="$(dirname "$(realpath "$0")")"

# Execute grub_server - stream output to terminal AND capture to temp file
# Pass has_unstaged_changes flag to server
remote_output_file="${client_tmpdir}/grub_${server}_${repo}_remote.out"

cat "${client_dir}/grub_server" | ssh "${server}" /bin/sh -s - "${server_root}" "${repo}" "${active_branch}" "${git_dir}" "${build_command}" "${server}" "${has_unstaged_changes}" | tee "$remote_output_file"
# Capture exit code of ssh command (middle of pipeline), not tee
ssh_command_exit=${PIPESTATUS[1]}

# Parse the captured output to extract the temp file paths
bld_out=$(grep "^GRUB_OUT=" "$remote_output_file" 2>/dev/null | cut -d= -f2)
bld_err=$(grep "^GRUB_ERR=" "$remote_output_file" 2>/dev/null | cut -d= -f2)

# Clean up the temporary output file
rm -f "$remote_output_file"

vecho "grub version: $VERSION"

if [ -z "$bld_out" ] || [ -z "$bld_err" ]; then
  echo "Error: Failed to retrieve remote temp file paths from grub_server output" >&2
  exit 4
fi

if [ $ssh_command_exit -gt 0 ]; then
  echo "Remote build failed with exit code $ssh_command_exit" >&2
fi

seconds_build=$(date '+%s')

vecho "Build complete:" $(date)

#
# Run the SFTP's in the background so they can process in parallel
# client_tmpdir already set and normalized above
#
bldout_out=$(sftp "${server}:${bld_out}" "${client_tmpdir}" 2>&1) &
pid_out=$!
blderr_err=$(sftp "${server}:${bld_err}" "${client_tmpdir}" 2>&1) &
pid_err=$!
wait ${pid_out} ${pid_err} # put the specific jobs in so that the RC will get set if the last command fails
rc=$?
if [ $rc -gt 0 ]; then
  echo "Warning: SFTP failed to download one or both of ${bld_out} and ${bld_err} from ${server}. rc ${rc}" >&2
  vecho "SFTP output details:" >&2
  vecho "${bldout_out}" >&2
  vecho "${blderr_err}" >&2
  # Don't exit - try to show what we can
fi

seconds_download=$(date '+%s')

# Extract just the filename from the remote path for local reference
local_bld_out="${client_tmpdir}/$(basename ${bld_out})"
local_bld_err="${client_tmpdir}/$(basename ${bld_err})"

if [ -f "${local_bld_out}" ]; then
  out=$(cat ${local_bld_out})
  if [ "${out}" != "" ]; then
    vecho "Output downloaded to ${local_bld_out}"
  fi
else
  echo "Warning: Output file ${local_bld_out} not found" >&2
fi

if [ -f "${local_bld_err}" ]; then
  err=$(cat ${local_bld_err})
  if [ "${err}" != "" ]; then
    vecho "Errors downloaded to ${local_bld_err}"
    echo "${err}" >&2
  fi
else
  echo "Warning: Error file ${local_bld_err} not found" >&2
fi

seconds_finish=$(date '+%s')

vecho "Finish:" $(date)

vecho "Times: "
vecho " patch create:   " $((seconds_patch-$seconds_start)) "s"
vecho " git sync:       " $((seconds_sync-$seconds_patch)) "s"
vecho " patch transfer: " $((seconds_transfer-$seconds_sync)) "s"
vecho " remote build:   " $((seconds_build-$seconds_transfer)) "s"
vecho " download:       " $((seconds_download-$seconds_build)) "s"
vecho "Total time:      " $((seconds_finish-$seconds_start)) "s"

if [ ${output} = "True" ]; then
  if [ -f "${local_bld_out}" ]; then
    echo "Output from ${local_bld_out}"
    cat "$local_bld_out"
  fi
  if [ -f "${local_bld_err}" ]; then
    echo "Errors from ${local_bld_err}"
    cat "$local_bld_err"
  fi
fi


# Use exit code of ssh command to exit script to determine overall exit code
# Cleanup will be handled by the trap handler
exit $ssh_command_exit
