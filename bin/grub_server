#!/bin/sh

#
# This script requires tight hand-shaking with grub_client
# for parameter passing from the client to the server
#

server_root="$1"
repo="$2"
active_branch="$3"
git_dir="$4"
build_command="$5"
server_name="$6"
has_unstaged_changes="$7"

# Platform check to see if we're on z/OS
uname_output=$(uname -s 2>/dev/null)
if echo "$uname_output" | grep -qi "OS/390"; then
  zos="True"
else
  zos="False"
fi


# Use TMPDIR if set, otherwise fall back to /tmp
tmpdir="${TMPDIR:-/tmp}"
bld_out="${tmpdir}/grub.${server_name}_${repo}.out"
bld_err="${tmpdir}/grub.${server_name}_${repo}.err"


# Setup z/OS tagging and auto conversion
if [ "${zos}" = "True" ]; then
  export _BPXK_AUTOCVT=ON
  export _CEE_RUNOPTS="$_CEE_RUNOPTS FILETAG(AUTOCVT,AUTOTAG)"
  export _TAG_REDIR_ERR=txt
  export _TAG_REDIR_IN=txt
  export _TAG_REDIR_OUT=txt

  # Make the log files up front so we can tag them
  touch "${bld_out}"
  touch "${bld_err}"

  chtag -tc ISO8859-1 "${bld_out}" 2>/dev/null || true
  chtag -tc ISO8859-1 "${bld_err}" 2>/dev/null || true
fi

# Echo paths back to client so it knows where to download from
echo "GRUB_OUT=${bld_out}"
echo "GRUB_ERR=${bld_err}"

#
# Add the git_dir to the PATH so that git and bash can be located
#

if [ -d "${git_dir}" ] ; then
  export PATH="${git_dir}:$PATH"
else
  echo "Unable to set up git PATH with ${git_dir}" >&2
  exit 4
fi

#
# We call a second script to do the 'real' work and
# redirect the stdout and stderr to files so the client
# can then download the output
#

# Change to repo directory and checkout branch
cd "$server_root/$repo" || {
  echo "Error: Failed to change to directory $server_root/$repo" >&2
  exit 4
}

# Checkout the branch (working directory was already cleaned by grub_client before push)
git checkout "$active_branch" >/dev/null 2>&1 || {
  echo "Error: Failed to checkout branch $active_branch" >&2
  exit 4
}

# Apply patch file if there were unstaged changes
if [ "$has_unstaged_changes" = "1" ]; then
  patch_file="${tmpdir}/grub.${server_name}_${repo}.patch"

  if [ -f "$patch_file" ]; then
    # Apply the patch
    git apply --whitespace=nowarn "$patch_file" 2>&1
    patch_result=$?

    if [ $patch_result -ne 0 ]; then
      echo "Error: Patch application failed (exit code: $patch_result)" >&2
      echo "This may indicate conflicts between your local changes and the remote branch" >&2
      exit 4
    fi

    # Clean up patch file after applying
    rm -f "$patch_file"
  else
    echo "Warning: Expected patch file $patch_file not found" >&2
  fi
fi


# Execute build command with buffered streaming using named pipes

echo "Executing command '$build_command'"

# Create named pipes for stdout and stderr
pipe_out="${tmpdir}/grub_${server_name}_${repo}_out.pipe"
pipe_err="${tmpdir}/grub_${server_name}_${repo}_err.pipe"
mkfifo "$pipe_out" "$pipe_err"

# Start tee processes in background to read from pipes and write to files/terminal
tee "${bld_out}" < "$pipe_out" &
tee "${bld_err}" < "$pipe_err" >&2 &

# Run build command with output redirected to named pipes
bash -c "$build_command" >"$pipe_out" 2>"$pipe_err"
build_exit_code=$?

# Wait for tee processes to finish
wait

# Clean up named pipes
rm -f "$pipe_out" "$pipe_err"

# Exit with the build command's exit code
exit $build_exit_code
