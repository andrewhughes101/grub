#!/bin/sh

#
# This script requires tight hand-shaking with grub_client
# for parameter passing from the client to the server
#

server_root="$1"
repo="$2"
active_branch="$3"
oef_dir="$4"
build_command="$5"
server_name="$6"
has_unstaged_changes="$7"

# Use TMPDIR if set, otherwise fall back to /tmp
tmpdir="${TMPDIR:-/tmp}"
bld_out="${tmpdir}/grub.${server_name}_${repo}.out"
bld_err="${tmpdir}/grub.${server_name}_${repo}.err"

# Echo paths back to client so it knows where to download from
echo "GRUB_OUT=${bld_out}"
echo "GRUB_ERR=${bld_err}"

#
# Add the oef_dir (Open Enterprise Foundation) directory
# for this server to the PATH so that bash and git can be located.
#

if [ -d "${oef_dir}" ] ; then
  export PATH="${oef_dir}:$PATH"
else
  echo "Unable to set up Open Enterprise Foundation PATH with ${oef_dir}" >&2
  exit 4
fi

export _BPXK_AUTOCVT=ON
export _CEE_RUNOPTS="$_CEE_RUNOPTS FILETAG(AUTOCVT,AUTOTAG)"
export _TAG_REDIR_ERR=txt
export _TAG_REDIR_IN=txt
export _TAG_REDIR_OUT=txt

#
# We call a second script to do the 'real' work and
# redirect the stdout and stderr to files so the client
# can then download the output
#

# Change to repo directory and checkout branch
cd "$server_root/$repo" || {
  echo "Error: Failed to change to directory $server_root/$repo" >&2
  exit 4
}

# Clean the working directory to ensure we can apply patches cleanly
# This removes any unstaged changes and untracked files from previous builds
git reset --hard HEAD >/dev/null 2>&1 || {
  echo "Warning: Failed to reset working directory" >&2
}
git clean -fd >/dev/null 2>&1 || {
  echo "Warning: Failed to clean untracked files" >&2
}

git checkout "$active_branch" >/dev/null 2>&1 || {
  echo "Error: Failed to checkout branch $active_branch" >&2
  exit 4
}

# Apply patch file if there were unstaged changes
if [ "$has_unstaged_changes" = "1" ]; then
  patch_file="${tmpdir}/grub_${server_name}_${repo}.patch"

  if [ -f "$patch_file" ]; then
    # Apply the patch
    git apply --whitespace=nowarn "$patch_file" 2>&1
    patch_result=$?

    if [ $patch_result -ne 0 ]; then
      echo "Error: Patch application failed (exit code: $patch_result)" >&2
      echo "This may indicate conflicts between your local changes and the remote branch" >&2
      exit 4
    fi

    # Clean up patch file after applying
    rm -f "$patch_file"
  else
    echo "Warning: Expected patch file $patch_file not found" >&2
  fi
fi


# Execute build command with buffered streaming using named pipes

echo "Executing command '$build_command'"

# Create named pipes for stdout and stderr
pipe_out="${tmpdir}/grub_${server_name}_${repo}_out.pipe"
pipe_err="${tmpdir}/grub_${server_name}_${repo}_err.pipe"
mkfifo "$pipe_out" "$pipe_err"

# Start tee processes in background to read from pipes and write to files/terminal
tee "${bld_out}" < "$pipe_out" &
tee "${bld_err}" < "$pipe_err" >&2 &

# Run build command with output redirected to named pipes
bash -c "$build_command" >"$pipe_out" 2>"$pipe_err"
build_exit_code=$?

# Wait for tee processes to finish
wait

# Clean up named pipes
rm -f "$pipe_out" "$pipe_err"

# Exit with the build command's exit code
exit $build_exit_code
